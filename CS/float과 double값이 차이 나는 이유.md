컴퓨터에서 숫자를 표현하는 개념은 이진소수점수(Binary)입니다.
이진법으로 표현한 이진소수점수는 무한이진소수점수, 유한이진소수점수로 나뉘는데요.
무한소수점수를 예로 들면, 1/3이 있습니다.

컴퓨터는 유한한 저장공간을 가지고 있기 때문에, 이 무한이진소수점수를 저장할 수가 없습니다.
그래서 일반적으로 32비트의 저장공간에 이 무한소수점수를 우겨넣고 나머지 뒷자리는 반올림 후 버립니다.
32비트 소수점수인 이것을 우리는 float이라고 부르며 64비트를 사용한 소수점수는 double이라고 부릅니다.

그리고 이 숫자를 보여줄 대상은 사람이므로 사람에게 익숙한 십진수 형태로 변환하여 표시합니다.

예를들어 십진수 0.1을 이진수로 변환하면
0.000110011001100110011001101 이고,
이를 십진수로 다시 변환하면,
0.10000000149011611938입니다.

이처럼, 컴퓨터에서는 십진수 0.1이 정확하게 표현이 될 수 없습니다.

이 0.10000000149011611938끼리 곱해봅시다.
그럼 0.01000000070780515671이 나옵니다.
하지만, 이 값은 0.01에 가장 근접한 값이 아닙니다.

0.01에 가장 가까운 이진소수점수는 0.00999999977648258209입니다.
컴퓨터에 0.01을 입력하게 되면. 0.01에 가장 근접한 이진소수점수를 저장하게 되고 이는 0.1을 두번 곱한 결과와는 다른 숫자입니다.

이것이 바로 근사치 연산의 오류입니다. 따라서 컴퓨터에서 0.1*0.1은 0.01이 false로 출력되게 되는 것입니다.

이쯤에서 왜 이진법으로 변환하는것인가 정수부를 기준으로 정수기준으로 생각하면 되는 것이 아니냐 등등의 의문점이 생길 수 있습니다.
기본적으로 컴퓨터에서의 소수점수는 아주 커다란 숫자나 아주 작은 숫자를 효율적인 리소스를 토대로 연산하기 위해 지원하기 시작했기 때문입니다.
CPU는 연산을 할 때 ALU에서 처리합니다만. 소수점수 연산을 할 때는 ALU(Arithmetic logic unit)의 일부에 있는 전문 소수점수 처리부인 FPU(Floating Point Unit)에서 처리하게 됩니다.
십진연산은 하드웨어적으로 효율이 좋지 않고 정수사이의 미세한 사이값을 계산하기 위해서라면 소프트웨어적으로 충분히 가능하기 떄문입니다. 그래서 항상 floating point 에서는 정밀도 문제가 따라붙게 되어 있으며
컴퓨터는 거의 항상 우리가 필요로 하는 소수점수의 값을 근사치로 계산하게 됩니다. 하지만 우리가 사용하는 일반적인 계산기 앱이나 은행에서의 수치 계산은 이런 근사치 계산이 아닌 정수를 여러개 묶어서
십진계산을 하기 떄문에 이런 오류는 발생하지 않습니다. 
